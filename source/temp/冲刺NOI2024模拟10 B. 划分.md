# [冲刺NOI2024模拟10 B. 划分](http://47.92.197.167:5283/contest/518)

- 规定
  - 一段：一般指原序列连续的一段 $0,1$ 序列
  - 一块：一般指与问题中要求划分的 $m$ 段
- 首先分析答案的形式
  - 答案序列形如 $00000,0000,000111,11111,1111$
- 猜一个结论：所有连续的一段 $0,1$ 都会被划分到同一块里
  - 例如：$000111000$，相当于 $[val:0,len:3][val:1,len:3][val:0,len:3]$
  - 证明：
  - 若序列形如 $[...110,0011,1100...]$，直接 $[...11,0001111,00...]$ 就好了
  - 若序列形如 $[...011,000,00111...]$，直接 $[...011,00000,111...]$ 就好了
- 那问题转化为，有一段带权 $0,1$ 序列，规定 $n$ 为新序列长度，$len$ 为原序列长度
- 若新序列为 $n\le 2$，特判掉，因为这些情况可能不存在 $01$ 划分为一块的情况
- 然后考虑至少需要划分成多少($m$)块才能满足此时的答案等于 $len$
  - 显然 $m=n-1$，具体如下
  - 若 $010101010$，$01,0,1,0,1,0,1,0$，注意这里 $m$ 是段数不是括号数
  - 其他的都一样吧，就是任选一个 $01$ 合并
- 然后考虑从后向前计算答案 $n-1,n-2,n-3,\cdots,1$
- 那我们包是考虑合并相邻的两块
  - 先不考虑 $01$ 块的情况，$0,1,0,1,0,01$ to $0,10,1,0,01$
  - 而这多少有点唐，因为我们完全可以 $0,101,0,01$ 其中 $101$ 做为 $1$ 出现在答案序列
  - 或者 $010,1,0,01$ 其中 $010$ 做为 $0$ 出现在答案序列
  - 这啥意思呢？就是说我们合并两块，还不如直接合并三块。
  - 那 $01$ 块怎么办，它就游走呗，只要存在至少三个相邻块，他就随便钦定一个 $01$ 块呗
- 考虑带悔贪心
  - 注意在两侧的段想要合并，只需要合并两块，比较特殊，但是我们可以枚举两端的两个块是否合并
  - 初始，每个有 $O(n)$ 个可以转移的状态，合并 $i-1,i,i+1$ 代价为 $v_i$
  - 注意若是两边（$1,n$）不合并，则 $2$ 和 $n-1$ 是不能转移的，而且不能先合并 $2$ 间接合并 $1$
  - 若是合并，你不妨就自主选择是否合并吧
  - 最后还有，由于我们 $01$ 块游走的前提是有 $3$ 至少个块，若是左右端点都钦定合并，我们并没有强制选择左右端点，所以可能导致 $1$ 个段的答案错误，那就单独算一下呗

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=300300,inf=0x3f3f3f3f; int nn;
vector<int> make()
{
    static char s[N]; int be=1;
    cin>>nn>>s+1; vector<int> p;
    for(int i=2;s[i];i++)if(s[i]!=s[i-1])
        p.push_back(i-be),be=i;
    p.push_back(nn-be+1);
    int f0=0,f1=0,c=s[1]-'0';
    for(int i=0;i<p.size();i++,c=!c)
        if(c)f1=max(f1,f0)+p[i];
        else f0+=p[i];
    cout<<max(f0,f1)<<" "; return p;
}
struct node{int val,pos,tim;};struct List{int l,r,val;};
bool operator< (const node &a,const node &b){return a.val>b.val;}
List s[N]; int ss[N]; int b[N];
int main()
{
    freopen("divide.in","r",stdin);
	freopen("divide.out","w",stdout);
    vector<int> a=make(); int n=a.size()-1;
    for(int b0:{0,1}) for(int bn:{0,1})
    {
        int ans=(!b0)*a[0]+(!bn)*a[n],len=n-b0-bn+1;
        priority_queue<node> q;
        for(int i=0;i<=n;i++)b[i]=i; int tim=n;
        s[0]={n+1,1,inf}; s[n]={n-1,n+2,inf};
        for(int i=1;i<n;i++)
        {
            s[i]={i-1,i+1,a[i]};ans+=s[i].val;
            if((b0 && i==1) || (bn && i==n-1)){s[i].val=inf;continue;};
            q.push({s[i].val,i,i});
        }ss[len]=max(ss[len],ans);
        while(q.size())
        {
            while(q.size()&&(b[q.top().pos]!=q.top().tim))q.pop();
            if(q.empty())break;  auto [val,P,tmp]=q.top();q.pop();
            len-=2;if(len<0)break;
            const int L=s[P].l,R=s[P].r;
            b[L]=b[R]=-1;b[P]=++tim; ans-=s[P].val;
            s[P].val=s[L].val+s[R].val-s[P].val;
            if(s[L].val<inf)s[P].l=s[L].l,s[s[P].l].r=P;else s[P].val=inf;
            if(s[R].val<inf)s[P].r=s[R].r,s[s[P].r].l=P;else s[P].val=inf;
            if(s[P].val<1e7&&s[P].val>-1e7) q.push({s[P].val,P,tim}); ss[len]=max(ss[len],ans);
        }
    }
    for(int i=0;i<=nn;i++)ss[i+1]=max(ss[i],ss[i+1]);
    for(int i=2;i<=nn;i++)cout<<ss[i+1]<<" ";cout<<'\n';
    return 0;
}
```