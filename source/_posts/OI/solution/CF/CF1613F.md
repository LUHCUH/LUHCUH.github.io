---
title: Tree coloring
tags:
  - Codeforces
date: 2024-11-14 18:39:29
---
### [Tree coloring](https://www.luogu.com.cn/problem/CF1613F)

- 题目简述：
  - 给一个 $n$ 个点的树的每个节点染不同的 $n$ 中颜色，对满足条件的染色方案计数，条件是：$col_{fa}+1\not=col_{son}$

- 我们考虑对不合法的方案计数，钦定一个点和他的父亲满足 $col_{fa}+1=col_{son}$，那么相当于二者绑定起来了，公用一个连续的双色
- 若我们随便选 $k$ 个点，使得其和其父亲绑定，至于其他点符不符合要求不做限制，考虑计算其方案数，二者绑定，相当于可随机染色的点数减 $1$，可染色颜色减 1。于是方案数为 $(n-k)!$
- 我们考虑应用上述的子集反演，我们有 $g(S)=$ 选择集合 $S$ 中的点，使得其与其父亲绑定，而全集中其他的点是否合法不做考虑的方案数。$f(S)=$ 选择集合 $S$ 中的点，使得有且仅有 $S$ 中的点不满足条件的方案数。
- 显然的，对于 $g(S)$  统计的方案数不只有 $f(S)$ 还有会统计更大更多的集合。于是便有 $g(S)=\sum\limits_{S\subseteq T} f(T)$
- 依据反演有 $f(\phi)=\sum_{\phi\subseteq T}(-1)^{|T|}g(T)$，$f(\phi)$ 即为所求。
- 我们考虑动态的维护这一过程。对于一个点，它有两种选择，要么被绑定，要么不被绑定。这里我们考虑和儿子绑定的情况，设 $u$ 有 $d_u$ 个儿子在树上，那么它与儿子绑定便有 $d_u$ 种情况，而不绑定有一种情况。于是我们计算可得，每个点的多项式为 $(1-d_ux)$，这里的减号是比较巧妙的。直接把容斥中 $(-1)$ 的系数夹杂在多项式中。
- 若我们把所有节点的贡献乘起来，有 $\prod\limits_{u\in tree}(1-d_ux)$，我们取这个多项式 $x^k$ 的系数，表示绑定了 $k$ 对点的方案数是多少，再乘上每种情况其他点的贡献 $(n-k)!$，累加就是答案 $Ans=\sum\limits_{i=0}^n[x^i](\prod\limits_{u\in tree}(1-d_ux))(n-i)!$
- 至此，已经有了 $O(n\log n^2)$ [的 $ntt$ 分治做法](https://codeforces.com/contest/1613/submission/285795309)。
- 接着有一种神奇的优化方法，设 $c_i=\sum_{u\in tree}[d_u=i]$。
- 我们有 $\sum\limits_{i=1}^nic_i=n$。而对于相同的 $d_u$。我们直接二项式定理求 $(1-d_u)^{c_{d_u}}$ 是容易的 $O(c_{d_u})$。若我们从 $n$ 往 $0$ 依次枚举 $i$，总复杂度 $=n\log n\sum\limits_{i=0}^n\sum\limits_{j=i}^nO(c_i)=O(n\log n\sum\limits_{i=1}^nic_i)=O(n\log n)$，我没写，口胡的。