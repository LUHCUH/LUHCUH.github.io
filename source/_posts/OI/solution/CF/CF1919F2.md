---
title: Wine Factory (Hard Version)
tags:
  - Codeforces
  - 网络流
  - 网络流优化
date: 2024-11-14 18:36:24
---
### [Wine Factory (Hard Version)](https://www.luogu.com.cn/problem/CF1919F2)
- 题目简述：有个网络流，中有 $S,T,i$ 共 $n+2$ 个点，$S$ 到 $i$ 有边权 $a_i$。$i$ 到 $T$ 有边权 $c_i$，$i$ 到 $i+1$ 有边权 $c_i$，让你求最大流，对了每次修改 $a_i,b_i,c_i$ 的边权后，求最大流
- 题解：
- Part 1：从线段树考虑，我们需要维护，第 $[l,r]$ 中的点的累加答案，最多还能从前面接受多少流，当前区间内还有多少能流出去的流，当前区间流完还剩多少流。之后直接线段树，$pushup$ 写明白了就万事大吉，不会的话阅读课文。
- Part 2：从网络流优化的角度考虑，
    - 首先：最大流转化为最小割，$(S,i),(i,T)$ 一定要割一个
    - 如果都不割，存在通路不符合题意。
    - 如果割了存在 $(i-1,i)$ 的流，与其两个都割，莫不如只割 $(i,T)$，（注意这里只是，说明了两个都割的不优秀，却没有反驳你一开始就选择 $(S,i)$）
    - 如果不存在 $(i-1,i)$ 的流，与其两个都割，莫不如只割 $(S,i)$，（注意：同上）
    - 之后我们考虑对于每一个区间都维护 左右端点，割上，割下的代价，共四种状态。
    - 值得注意的是，若我们选择割了 $(i-1,T),(S,i)$ 想一想，相当于我们假设了 $(i-2,i-1)$ 存在，$(i-1,i)$ 不存在，而我们没有割 $(S,i-1)$，故割掉 $(i-1,i)$ 呱！
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 500500;
#define ls (x<<1)
#define rs (x<<1|1)
#define Ls ls,l,m
#define Rs rs,m+1,r
// 还有..能变成酒    都成酒后还能流      当前流         答案
typedef long long ll; const ll inf = 0x3f3f3f3f3f3f3f3f;
ll towine[N << 2], max_flow[N << 2], flow[N << 2], ans[N << 2], a[N], b[N], c[N];
void up(int x)
{
    ans[x] = ans[ls] + ans[rs];
    max_flow[x] = min(max(max_flow[ls] - towine[rs], 0ll) + flow[rs], max_flow[rs]);
    towine[x] = towine[ls] + min(max(towine[rs] - flow[ls], 0ll), max_flow[ls] - flow[ls]);
    flow[x] = min(max(flow[ls] - towine[rs], 0ll) + flow[rs], max_flow[rs]);
    ans[x] += min(towine[rs], flow[ls]);
}
void bud(int x, ll a, ll b, ll c)
{
    ans[x] = min(a, b);
    towine[x] = max(b - a, 0ll);
    flow[x] = min(max(a - b, 0ll), c);
    max_flow[x] = c;
}
void bud(int x, int l, int r)
{
    if (l == r)return bud(x, a[l], b[l], c[l]);
    int m = l + r >> 1; bud(Ls); bud(Rs); up(x);
}
void upd(int x, int l, int r, int p)
{
    if (l == r)return bud(x, a[l], b[l], c[l]);
    int m = l + r >> 1; if (p <= m)upd(Ls, p); else  upd(Rs, p); up(x);
}
int main()
{
    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    for (int i = 1; i < n; i++)cin >> c[i]; c[n] = inf;
    bud(1, 1, n);
    for (int i = 1; i <= m; i++)
    {
        int p; ll x, y, z; cin >> p >> x >> y >> z;
        a[p] = x; b[p] = y; c[p] = z; c[n] = inf;
        upd(1, 1, n, p); cout << ans[1] << '\n';
    }
    return 0;
}
```