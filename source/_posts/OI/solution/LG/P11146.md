---
title: 「SFMOI Round I」Strange Train Game
tags:
  - 洛谷
  - 带悔贪心
date: 2024-11-14 18:18:58
---

### [「SFMOI Round I」Strange Train Game](https://www.luogu.com.cn/problem/P11146)
- 题目简述：有两个长度是 $n$ 的序列 $a_i,b_i$ 你可以进行若干次操作使得 $a$ 序列字典序最大。$m$ 个操作，给出 $l_i,r_i$ 一次操作为 $i\in[l,r],swap(a_i,b_i)$
- 题解：
- 首先对于每个点 $i$，若 $a_i<b_i$ 显然我们希望，翻转次数为奇数，$a_i>b_i$ 翻转次数为偶数，至于 $a_i=b_i$ 无所谓了，依次确定求出最大字典序。
- 怎么办呢，区间前后总有交集。
- 发现区间 $[l,r_1],[l,r_2],[l,r_k]$ 这 $k$ 个区间若按照 $r_i$ 从小到大排序，显然我们可以只考虑 $[l,r_1]$，至于 $[l,r_2]$ 可以转化为区间 $[r_1+1,r_2]$，同理 $[r_1+1,r_k]$。这样一个段只能被一个区间所贡献。我们只考虑这一个区间的存留即可。
- 具体的若 $a_i=b_i$，$[l,r_1]$ 用不用都行。
- 若 $a_i<b_i$，$[l,r_1]$ 必须当前用掉，若后面更改的 $l$ 的翻转次数，只需不用即可。
- 若 $a_i>b_i$，$[l,r_1]$ 不必立即用掉，但是需要为之后使用 $[l,r_2]$ 做预留，可以抵消区间。
- 详细的请看代码理解
- 其实还有第二种表示方案：建图
- 我们考虑删除 $a_i=b_i$ 的点，这是必要的，否则影响建图的正确性。
- 对于操作 $[l,r]$ 我们建边 $(l,r+1)$ 这样你会惊奇的发现，两个区间 $(l,r),(r+1,k)$ 联通了 $(l,k)$ 而恰好我们也存在翻转 $(l,k)$ 的方案，而想回连也同理，$(l,r),(k,r)$ 可构造 $(l,k-1)$。
- 那么我们建完图联通的两个点必然有 $(i,j-1)$ 区间是可反转的。
- 我们考虑在必须翻转的时候翻转最长的区间一定是对的。如果要选择较短的区间，只需要在未来在翻转一次后缀即可。
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 200200;
char a[N], b[N];
int ans[N]; set<int> s[N];
int main()
{
    int n, m; cin >> n >> m;
    cin >> a + 1 >> b + 1;
    for (int i = 1; i <= m; i++)
    {
        int l, r; cin >> l >> r;
        s[l].insert(r);
    }
    for (int i = 1, tag = 0; i <= n; i++)
    {
        tag ^= ans[i];
        if (s[i].empty());
        else if (a[i] == b[i])
        {
            if (s[i].count(i))s[i].erase(i);
            if (s[i + 1].size() < s[i].size())swap(s[i + 1], s[i]);
            s[i + 1].insert(s[i].begin(), s[i].end());
        }
        else
        {
            int p = *s[i].begin() + 1; s[i].erase(s[i].begin());
            if (s[p].size() < s[i].size())swap(s[p], s[i]);
            s[p].insert(s[i].begin(), s[i].end());
            if ((a[i] < b[i]) ^ tag)ans[p] ^= 1, tag ^= 1;
        }
        cout << char(tag ? b[i] : a[i]);
    }
    return 0;
}
```
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 200200;
char a[N], b[N]; int ans[N], f[N], fr[N], ne[N];
int getf(int x) { return f[x] < 0 ? x : f[x] = getf(f[x]); }
void hb(int x, int y)
{
    x = getf(x); y = getf(y);
    if (x == y)return;
    if (x < y)swap(x, y);
    f[x] += f[y]; f[y] = x;
}
int main()
{
    memset(f, -1, sizeof f);
    int n, m; cin >> n >> m;
    cin >> a + 1 >> b + 1;
    fr[1] = 1;
    for (int i = 2; i <= n; i++)
        fr[i] = a[i - 1] == b[i - 1] ? fr[i - 1] : i;
    for (int i = 1; i <= n; i++)
        ne[i] = a[i] == b[i] ? ne[i - 1] : i;
    for (int i = 1; i <= m; i++)
    {
        int l, r; cin >> l >> r; if (fr[l] <= ne[r]) hb(fr[l], ne[r] + 1);
    }
    for (int i = 1, tag = 0; i <= n; i++)
    {
        tag ^= ans[i];
        if (a[i] ^ b[i] && (a[i] < b[i]) ^ tag && getf(fr[i]) != fr[i])ans[getf(fr[i])] ^= 1, tag ^= 1;
        cout << (tag ? b[i] : a[i]);
    }
    return 0;
}
```