---
title: D
message: dsfz NOI篇 的密码
tags:
  - accnoi
  - 延迟处理
  - 计数
date: 2024-11-20 07:47:53
---

### [禁止套娃](http://47.92.197.167:5283/submission/261509)

- 题记：此题，题目简洁简单易写，怎奈作者没水平，没思路，看不懂题解，视频，课文，有愧于伟大的(...)
- 题目描述：定义从序列 $a$ 到序列集合 $S$ 的映射 $S=f(a)$ 为，$S$ 是 $a$ 的所有子序列组成的去重集合。即相
同的子序列在其中只考虑一次。空序列是任何序列的子序列。子序列在原序列中不一定对应连续的位置。
- 给定 $n$ 以及序列 $a_{1\cdots n}$，求：
$$
\sum_{b\in f(a)}|f(b)|\pmod{10^9+7}
$$
- $n\le 5\times 10^3$
- 题目分析
- Part1：暴力枚举内外集合 $O(2^{2n})$
- Part2：思考？如何对一个序列的本质不同子序列计数呢？
  - 考虑计数经典做法，钦定极值，以做到不冲不漏
  - 具体的，我们钦定一个小的子序列 $a_{t_0}\cdots a_{t_k}$，向外扩展到 $a_{t_0}\cdots a_{t_{k+1}}$ 时
  - 需要满足，在区间 $i\in(t_k,t_{k+1})$ 中，没有 $a_i=a_{t_{k+1}}$
  - 这样的话，对于任意的子序列，我们一定在原序列中最先能找到它的地方统计它。
  - 借用题解的话！
  - 令 $dp_i$ 表示末尾选 $i$ 的本质不同子序列数，则 $dp_0 = 1$, $dp_i = \sum_{j=pre_i}^{i−1}dp_j$，$pre_i$ 表示上一
个与 $a_i$ 相等的位置，如果不存在则为 $0$。
- Part3：思考？进一步的不用想也知道必然是两层放一起 $dp$
  - 我们考虑枚举 $b$ 序列的样子，首先，$b$ 序列是 $a$ 的子序列，那必然也是原序列的子序列
  - 我们大概考虑要如何 $dp$，设 $dp_i$ 表示选择的 $b$ 序列以位置 $i$ 为结尾，的方案书
  - $dp_i=\sum_{j=0}^{i-1} dp_{j}\times tr_{i,j}$ 这里考虑新建节点 $n+1$，$dp_{n+1}$ 就是答案
  - 接着，我们来解决最重要的部分，怎么给 $tr$，$dp$ 出来
  - 我们考虑 $tr_{i,j}$ 选出的电集合 $P=\{a_{t_1}\cdots,a_{t_k}\}$，我们显然有 $t_1=i,t_k=j$
    - 一句废话，$dp$ 是合成答案，$tr$ 是对 $a,b$ 序列和发情况的判断
    - 限制 $1$ 对于相邻的两个数 $a_{t_i},a_{t_{i+1}}$ 需满足，$i\in(t_i,t_{i+1})$，$a_i\not= a_{t_{i+1}}$，这一部分其实就是对 $a$ 序列的选择做 Part2 的限制。
    - 限制 $2$ 我们还需要满足 $i\in [2,k-1] a_{t_i}\not=a_{t_k}$，这一部分是对 $b$ 序列做 Part2 的限制。
  - 其实到这里就可以结束了，可是，我到这里就不会写代码了，额
  - 没准 $O(n^2)$ 的代码确实需要思考一些东西。
  - 基本的，我们有错误的 $dp$ 但，可以准确描述我们正在做的事
$$
tr_{i,j}=\sum_{k=i+1}^j tr_{k,j}+1
$$
  - 枚举最前面的两个位置分别是什么 $i,k$，之后还有直接 $i\to j$ 是否可以（$1$ 那个贡献）
  - 可是这里没有满足任何限制，我们尝试满足限制 $1$。仔细分析，其实我需要考虑的就是
$$
tr_{i,j}=\sum_{k=i+1}^j (pre_{k}<i)tr_{k,j}+1
$$
  - 什么意思，如果你的上一个出现位置也在 $k$ 的枚举范围中，我们是不能跨过 $pre_k$ 直接连到 $k$ 的。若 $pre_k=i$，无伤大雅，但是在往前就不行了
  - 然后呢？现在显然复杂度不对呀，我们考虑我们钦定结尾 $j$ 不变，向前地推 $i,i-1,\cdots 0$，我们的转移点，相当于还需要动态维护，值域个，也就是说，对于 $a_k$ 相同的，我们只保存最小的 $k$ 满足 $i<k$ 的即可，只有这些点可以转移过来。
  - 这很简单，我们考虑最累加和，累加 $tr$，当 $i$，地推到 $pre_i$ 的时候，删除 $i$ 的贡献即可啦。
  - 最后还有限制 $2$，本质就是我们中间部分不存在等于结尾 $a_j$ 的数，那就考虑 $tr_{k,j}$ 的时候，若 $a_k=a_j$ 我们就去掉 $tr$ 对累加的贡献
  - 原因是简单的，因为我们转移是，允许头尾相同，但中间不能有和尾相同的，而 $tr$ 是我们要计算答案的，自然不能删除，但是此时的 $tr$ 对在之前的转移也是没影响了，所以可以不累加。
  - 之后就没啥了，看代码就懂了

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5500;
typedef long long ll;const ll mod = 1000000007;
int n, a[N], vis[N]; ll pre[N], nxt[N], t[N], tr[N][N], sm[N][N], dp[N];
void Add(ll& a, ll b) { if ((a += b) >= mod)a -= mod; }
int main()
{
    freopen("nest.in", "r", stdin);
    freopen("nest.out", "w", stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n; int m = 0;
    for (int i = 1;i <= n;i++) cin >> a[i], m = max(m, a[i]);
    a[n + 1] = m + 1; n++; m++;
    for (int i = 1;i <= n;i++)pre[i] = vis[a[i]], vis[a[i]] = i;
    for (int i = 0;i <= m;i++)vis[i] = n + 1;
    for (int i = n;i >= 1;i--)nxt[i] = vis[a[i]], vis[a[i]] = i;
    for (int j = 1;j <= n;j++)
    {
        ll sm = 1;
        for (int i = 0;i <= n + 1;i++)t[i] = 0; t[j] = 1;
        for (int i = j - 1;i >= 0;i--)
        {
            t[i] = tr[i][j] = sm;
            if (a[i] == a[j]) t[i] = 0;
            sm = (sm - t[nxt[i]] + t[i]) % mod;
        }
    }
    dp[0] = 1;
    for (int j = 1;j <= n;j++)
    {
        for (int i = 0;i < j;i++)
            dp[j] += dp[i] * tr[i][j] % mod;
        dp[j] %= mod;
    }
    cout << (dp[n] % mod + mod) % mod << '\n';
    return 0;
}

```